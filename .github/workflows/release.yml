name: Plugin Release

# 触发条件：
# 1. package.json/package.v2.json 变动时自动触发
# 2. 手动触发（可指定版本递增类型：patch/minor/major）
on:
  push:
    paths:
      - 'package.json'
      - 'package.v2.json'
      - 'plugins/**'
      - 'plugins.v2/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: '版本递增类型（默认patch）'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch  # 补丁版（1.0.0→1.0.1）
          - minor  # 次版本（1.0.0→1.1.0）
          - major  # 主版本（1.0.0→2.0.0）

permissions:
  contents: write  # 授予写入代码、标签、Release的权限

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 拉取完整历史（用于对比版本/标签）
          token: ${{ secrets.PAT_TOKEN || github.token }}  # 兼容分支保护（PAT_TOKEN可选）

      # 步骤1：配置Git用户（用于提交版本号修改）
      - name: Configure Git user
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      # 步骤2：安装依赖（jq用于解析/修改JSON，zip用于打包）
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq zip

      # 步骤3：定义版本递增函数（核心：同步更新package文件版本）
      - name: Bump version and update package files
        id: bump_version
        run: |
          set -euo pipefail

          # 读取手动触发的版本类型（默认patch）
          VERSION_TYPE="${{ github.event.inputs.version_type || 'patch' }}"
          echo "版本递增类型：$VERSION_TYPE"

          # 版本递增函数：传入package文件路径，处理该文件内的所有插件版本
          bump_package_versions() {
            local pkg_file="$1"
            [ -f "$pkg_file" ] || return 0

            echo "===== 处理 $pkg_file ====="

            # 提取所有需要发布的插件（release=true）：输出格式 KEY|VERSION
            mapfile -t entries < <(jq -r 'to_entries | map(select(.value.release == true)) | .[] | "\(.key)|\(.value.version)"' "$pkg_file")

            if [ "${#entries[@]}" -eq 0 ]; then
              echo "No plugins with release=true in $pkg_file"
              return 0
            fi

            # 临时文件（避免直接修改原文件导致jq报错）
            tmp_file=$(mktemp)
            cp "$pkg_file" "$tmp_file"

            for entry in "${entries[@]}"; do
              plugin_id="${entry%%|*}"
              current_version="${entry##*|}"
              plugin_id_lc="$(echo "$plugin_id" | tr '[:upper:]' '[:lower:]')"

              echo "--- 处理插件 $plugin_id 当前版本：$current_version ---"

              # 拆分语义化版本号（MAJOR.MINOR.PATCH）
              IFS='.' read -r MAJOR MINOR PATCH <<< "$current_version"
              # 按类型递增版本
              case "$VERSION_TYPE" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  ;;
              esac
              new_version="$MAJOR.$MINOR.$PATCH"
              echo "递增后版本：$new_version"

              # 更新临时文件中的插件版本号
              jq --arg plugin "$plugin_id" --arg version "$new_version" \
                 '.[$plugin].version = $version' "$tmp_file" > "$pkg_file"
              rm -f "$tmp_file"

              # 输出版本信息（供后续步骤使用）
              echo "::set-output name=${plugin_id}_new_version::$new_version"
              echo "${plugin_id}_new_version=$new_version" >> "$GITHUB_ENV"
            done
          }

          # 处理package.json和package.v2.json
          bump_package_versions "package.json"
          bump_package_versions "package.v2.json"

          # 提交版本号修改（同步到仓库）
          if git diff --quiet; then
            echo "无版本号需要更新，跳过提交"
          else
            git add package.json package.v2.json
            git commit -m "chore: 自动递增插件版本号（类型：$VERSION_TYPE）"
            git push origin "${GITHUB_REF#refs/heads/}"  # 推送到当前分支
            echo "版本号已提交到仓库"
          fi

      # 步骤4：打包并发布变动的插件（兼容原有逻辑，使用新版本号）
      - name: Build and release changed plugins
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # 跟踪已处理的标签（避免重复）
          : > processed_tags.txt

          # 打包发布函数
          process_package() {
            local pkg_file="$1"
            [ -f "$pkg_file" ] || return 0

            echo "===== 打包发布 $pkg_file 中的插件 ====="

            # 提取需要发布的插件（release=true）
            mapfile -t entries < <(jq -r 'to_entries | map(select(.value.release == true)) | .[] | "\(.key)|\(.value.version)"' "$pkg_file")

            for entry in "${entries[@]}"; do
              plugin_id="${entry%%|*}"
              plugin_version="${entry##*|}"  # 使用更新后的版本号
              plugin_id_lc="$(echo "$plugin_id" | tr '[:upper:]' '[:lower:]')"

              # 查找插件目录（优先plugins.v2，其次plugins）
              dir1="plugins/${plugin_id_lc}"
              dir2="plugins.v2/${plugin_id_lc}"
              plugin_dir=""
              [ -d "$dir1" ] && plugin_dir="$dir1"
              [ -d "$dir2" ] && plugin_dir="$dir2"

              if [ -z "$plugin_dir" ]; then
                echo "WARN: 插件 $plugin_id 的目录不存在（$dir1/$dir2），跳过"
                continue
              fi

              # 生成标签和资产文件名（使用新版本号）
              tag="${plugin_id}_v${plugin_version}"
              asset="${plugin_id_lc}_v${plugin_version}.zip"

              # 跳过已处理的标签
              if grep -qxF "$tag" processed_tags.txt; then
                echo "标签 $tag 已处理，跳过"
                continue
              fi

              # 检查插件目录是否有变动（对比最近的同插件标签）
              prev_tag="$(git tag --list "${plugin_id}_v*" --sort=-version:refname | head -n 1 || true)"
              changed=1
              if [ -n "$prev_tag" ]; then
                if git diff --quiet "$prev_tag" -- "$plugin_dir"; then
                  echo "插件 $plugin_id 目录自 $prev_tag 后无变动，跳过打包"
                  changed=0
                fi
              fi

              if [ "$changed" -eq 0 ]; then
                echo "$tag" >> processed_tags.txt
                continue
              fi

              # 打包插件（排除缓存文件）
              echo "打包插件 $plugin_id v$plugin_version → $asset"
              rm -f "$asset"
              (cd "$(dirname "$plugin_dir")" && zip -r "$GITHUB_WORKSPACE/$asset" "$(basename "$plugin_dir")" -x "*/__pycache__/*" -x "*.pyc") >/dev/null

              # 删除已存在的同名Release/标签（避免冲突）
              if gh release view "$tag" >/dev/null 2>&1; then
                echo "Release $tag 已存在，删除旧版本..."
                gh release delete "$tag" -y
                git push origin :refs/tags/"$tag" || true
              fi
              git tag -d "$tag" >/dev/null 2>&1 || true

              # 创建新Release（使用新版本号）
              echo "创建Release $tag"
              gh release create "$tag" "$asset" \
                --title "$plugin_id v$plugin_version" \
                --notes "Automated release of $plugin_id $plugin_version (类型：${{ github.event.inputs.version_type || 'patch' }})" \
                --latest \
                --target "$GITHUB_SHA"

              echo "$tag" >> processed_tags.txt
              echo "✅ 插件 $plugin_id v$plugin_version 发布完成"
            done
          }

          # 执行打包发布
          process_package "package.json"
          process_package "package.v2.json"
